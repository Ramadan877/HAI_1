<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Chat with AI</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
</head> 
<body>
    <div class="start-overlay" id="start-overlay">
        <div class="start-trial-selector">
            <div class="participant-id-container">
                <label for="participant-id">Participant ID:</label>
                <input type="text" id="participant-id" class="participant-id-input" required>
            </div>
            <h2 class="start-trial-title">Select Task Type</h2>
            <div class="start-trial-buttons">
                <button id="start-trial1-btn" class="start-trial-btn" onclick="startWithTrial('Trial_1')">Task 1</button>
                <button id="start-trial2-btn" class="start-trial-btn" onclick="startWithTrial('Trial_2')">Task 2</button>
                <button id="start-test-btn" class="start-trial-btn" onclick="startWithTrial('Test')">Test Mode</button>
            </div>
        </div>
    </div>

    <div class="ready-overlay" id="ready-overlay">
        <div class="ready-content">
            <button id="start-interaction-btn" class="start-interaction-btn">
                Start
            </button>
        </div>
    </div>

    <div class="container">
        <div id="pdf-container">
            <canvas id="pdf-canvas"></canvas>
            <div id="loading-spinner" class="loading-spinner"></div>
        </div>

        <div class="page-controls">
            <button class="page-btn" id="prev-page"><i class="fas fa-chevron-left"></i></button>
            <div class="page-counter">
                <span id="current-page-num">1</span> / <span id="total-pages">-</span>
            </div>
            <button class="page-btn" id="next-page"><i class="fas fa-chevron-right"></i></button>
        </div>
    </div>

    <div class="avatar-container" id="chat-avatar">
        <div class="siri-orb">
            <div class="blob blob1"></div>
            <div class="blob blob2"></div>
            <div class="blob blob3"></div>
        </div>
    </div>

    <div class="modal" id="chat-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2></h2>
                    <span class="close-btn" id="close-modal">&times;</span>
            </div>

            <div class="chat-container" id="chat-container"></div>

            <div class="input-bar">
                <!-- WhatsApp-style voice recorder -->
                <div id="whatsapp-recorder" class="whatsapp-recorder" style="display: none;">
                    <button id="cancel-record-btn" class="recorder-btn cancel-btn">
                        <i class="fas fa-times"></i>
                    </button>
                    
                    <div class="waveform-container-wa">
                        <div class="recording-timer">0:00</div>
                        <div class="waveform-display">
                            <div class="waveform-bars" id="waveform-bars"></div>
                        </div>
                    </div>
                    
                    <button id="pause-record-btn" class="recorder-btn pause-btn">
                        <i class="fas fa-pause"></i>
                    </button>
                    
                    <button id="send-record-btn" class="recorder-btn send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
                
                <!-- Default state buttons -->
                <div id="default-controls" class="default-controls">
                    <button class="action-btn delete-btn" id="delete-btn">
                        <i class="fas fa-trash"></i>
                    </button>
                    <canvas id="voice-visualizer"></canvas>
                    <button class="action-btn" id="record-btn">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button class="action-btn pause-btn" id="pause-btn" style="display: none;">
                        <i class="fas fa-pause"></i>
                    </button>
                </div>
            </div>
            
            <div class="loading-indicator" id="loading-indicator">
                <div class="loading-orbit">
                    <div class="orbit-circle"></div>
                    <div class="orbit-circle"></div>
                    <div class="orbit-circle"></div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const url = '/resources/Extraneous Variables.pdf';
            const readyOverlay = document.getElementById('ready-overlay');
            const selectedTaskType = document.getElementById('selected-task-type');
            const startInteractionBtn = document.getElementById('start-interaction-btn');
            const startOverlay = document.getElementById('start-overlay');
            const avatar = document.getElementById('chat-avatar');
            const modal = document.getElementById('chat-modal');
            const closeModal = document.getElementById('close-modal');
            const recordBtn = document.getElementById('record-btn');
            document.getElementById('pause-btn').addEventListener('click', () => {
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'pause_legacy',
                    action: isPaused ? 'resume' : 'pause',
                    concept: getCurrentConcept(),
                    timestamp: new Date().toISOString()
                });
                togglePause();
            });
            document.getElementById('delete-btn').addEventListener('click', () => {
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'delete_legacy',
                    was_recording: isRecording,
                    was_paused: isPaused,
                    concept: getCurrentConcept(),
                    timestamp: new Date().toISOString()
                });
                deleteRecording();
            });
            const chatContainer = document.getElementById('chat-container');
            const loadingIndicator = document.getElementById('loading-indicator');
            const visualizer = document.getElementById('voice-visualizer');
            const siriOrb = document.querySelector('.siri-orb');
            const blobs = document.querySelectorAll('.blob');
            const userMessages = document.querySelectorAll('.user-message');
            const lastUserMessage = userMessages[userMessages.length - 1];
            if (lastUserMessage) {
                const transcriptDiv = lastUserMessage.querySelector('.transcript-text');
                if (transcriptDiv) {
                    transcriptDiv.textContent = data.user_transcript;
                }
            }

            let participantId = null;
            let trialType = null;
            let attemptCount = 0;
            let currentTrialType = null;
            let isRecording = false;
            let appStarted = false;
            let isSubmitting = false;
            let isPaused = false;
            let audioChunks = [];
            let mediaRecorder = null;
            let isAnimating = false;
            let waves = [];
            let isResizing = false;
            let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight, resizeStartLeft, resizeStartTop;
            let waveCount = 0;
            let currentConcept = "Default";
            let introPlayed = false; 
            let pdfDoc = null,
            pageNum = 1,
            pageRendering = false,
            pageNumPending = null,
            scale = 1.5,
            visualizerCanvas = document.getElementById('pdf-canvas'),
            visualizerCtx = visualizerCanvas.getContext('2d');
            updateInputBarState('idle');

            window.USE_STREAMING = false;

            function updateInputBarState(state) {
                const recordBtn = document.getElementById('record-btn');
                const pauseBtn = document.getElementById('pause-btn');
                const deleteBtn = document.getElementById('delete-btn');
                const visualizer = document.getElementById('voice-visualizer');
                const loadingIndicator = document.getElementById('loading-indicator');
                const defaultControls = document.getElementById('default-controls');
                const whatsappRecorder = document.getElementById('whatsapp-recorder');

                switch(state) {
                    case 'idle':
                        defaultControls.style.display = 'flex';
                        whatsappRecorder.style.display = 'none';
                        recordBtn.style.display = 'flex';
                        pauseBtn.style.display = 'none';
                        deleteBtn.style.display = 'none';
                        visualizer.style.display = 'none';
                        loadingIndicator.classList.remove('active');
                        break;
                    case 'recording':
                        loadingIndicator.classList.remove('active');
                        break;
                    case 'loading':
                        defaultControls.style.display = 'flex';
                        whatsappRecorder.style.display = 'none';
                        recordBtn.style.display = 'none';
                        pauseBtn.style.display = 'none';
                        deleteBtn.style.display = 'none';
                        visualizer.style.display = 'none';
                        loadingIndicator.classList.add('active');
                        break;
                }
            }

            window.audioContext = null;
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                window.audioContext = new AudioContext();
            } catch (e) {
                console.error('Web Audio API is not supported in this browser', e);
            }

            window.startWithTrial = function(trialType) {
                if (appStarted || isSubmitting) return false;

                const participantId = document.getElementById('participant-id').value.trim();
                if (!participantId) {
                    alert('Please enter a Participant ID');
                    return false;
                }

                logInteractionEvent('BUTTON_CLICK', {
                    button: 'start_trial',
                    trial_type: trialType,
                    participant_id: participantId,
                    timestamp: new Date().toISOString()
                });

                isSubmitting = true;
                const buttons = document.querySelectorAll('.start-trial-btn');
                buttons.forEach(btn => btn.disabled = true);

                window.participantId = participantId;
                window.currentTrialType = trialType;
                console.log('Starting trial with:', {
                    trial_type: trialType,
                    participant_id: participantId
                });


                if (typeof startScreenRecording === 'function') {
                    try { if (typeof cleanupScreenRecording === 'function') { cleanupScreenRecording().catch(()=>{}); } } catch(_){}

                    try { startScreenRecording().catch(err => { console.warn('V1: startScreenRecording failed (non-blocking):', err); }); } catch(e) { console.warn('V1: startScreenRecording call error', e); }
                }

                fetch('/set_trial_type', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        trial_type: trialType,
                        participant_id: participantId
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(response.status === 400 ? 'Missing participant ID' : 'Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                        if (data.status === 'success') {
                            currentTrialType = trialType;
                            console.log(`Starting with trial type: ${trialType}, Participant ID: ${participantId}`);
                            startOverlay.style.opacity = "0";
                            setTimeout(() => {
                                startOverlay.style.display = "none";
                                readyOverlay.classList.add('show');
                            }, 500);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Error starting trial: ' + error.message);
                    })
                    .finally(() => {
                        isSubmitting = false;
                        buttons.forEach(btn => btn.disabled = false);
                    });

                return false;
            };

            startInteractionBtn.addEventListener('click', function() {
                if (!currentTrialType) return;
                
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'start_interaction',
                    trial_type: currentTrialType,
                    participant_id: window.participantId,
                    timestamp: new Date().toISOString()
                });
                
                let initialPage = 1;
                switch(currentTrialType) {
                    case 'Test':
                        initialPage = 3;
                        break;
                    case 'Trial_1':
                        initialPage = 5;
                        break;
                    case 'Trial_2':
                        initialPage = 7;
                        break;
                }
                
                pageNum = initialPage;
                if (pdfDoc) {
                    queueRenderPage(initialPage);
                }
                
                if (typeof changeTrial === 'function') {
                    changeTrial(currentTrialType, document.getElementById('participant-id').value);
                }

                    appStarted = true;

                readyOverlay.classList.remove('show');
                setTimeout(() => {
                    readyOverlay.style.display = "none";
                    showModal();
                }, 300);
                
                animateBlobs();
            });

            function renderPage(num) {
                pageRendering = true;

                pdfDoc.getPage(num).then(function(page) {
                    const pdfContainer = document.getElementById('pdf-container');
                    const containerWidth = pdfContainer.clientWidth;
                    const containerHeight = pdfContainer.clientHeight;
                    
                    const viewport = page.getViewport({ scale: 1.0 });
                    const scaleWidth = containerWidth / viewport.width * 0.85;  
                    const scaleHeight = containerHeight / viewport.height * 0.85;
                    const optimalScale = Math.min(scaleWidth, scaleHeight);
                    
                    const scaledViewport = page.getViewport({ scale: optimalScale });
                    
                    canvas.height = scaledViewport.height;
                    canvas.width = scaledViewport.width;

                    const scaleFactor = window.devicePixelRatio || 1;
                    visualizerCanvas.width = scaledViewport.width * scaleFactor;
                    visualizerCanvas.height = scaledViewport.height * scaleFactor;

                    visualizerCtx.setTransform(scaleFactor, 0, 0, scaleFactor, 0, 0);

                    const renderContext = {
                        canvasContext: visualizerCtx,
                        viewport: scaledViewport
                    };
                    
                    const renderTask = page.render(renderContext);

                    renderTask.promise.then(function() {
                        pageRendering = false;

                        if (pageNumPending !== null) {
                            renderPage(pageNumPending);
                            pageNumPending = null;
                        }
                    });

                    updateModalTitle(num);
                    
                    const newConcept = getConceptNameForSlide(num);
                    if (currentConcept !== newConcept) {
                        currentConcept = newConcept;
                        notifyConceptChange(currentConcept);
                    }
                });

                document.getElementById('current-page-num').textContent = num;
            }

            window.addEventListener('resize', () => {
                if (pdfDoc) {
                    queueRenderPage(pageNum);
                }
            });

            function updateModalTitle(pageNumber) {
                const chatModalHeader = document.querySelector('.modal-header h2');
                const concept = getConceptNameForSlide(pageNumber) || "Have Fun!!"; 
                chatModalHeader.innerHTML = '<span class="concept-label">Current Concept: </span>' + concept;
            }

            function queueRenderPage(num) {
                if (pageRendering) {
                    pageNumPending = num;
                } else {
                    renderPage(num);
                }
            }

            function onPrevPage() {
                if (pageNum <= 1) return;
                
                logInteractionEvent('NAVIGATION', { 
                    button: 'previous_page',
                    from_page: pageNum,
                    to_page: pageNum - 1,
                    from_concept: getConceptNameForSlide(pageNum),
                    to_concept: getConceptNameForSlide(pageNum - 1),
                    timestamp: new Date().toISOString()
                });
                
                pageNum--;
                queueRenderPage(pageNum);
            }

            function onNextPage() {
                if (pageNum >= pdfDoc.numPages) return;
                
                logInteractionEvent('NAVIGATION', { 
                    button: 'next_page',
                    from_page: pageNum,
                    to_page: pageNum + 1,
                    from_concept: getConceptNameForSlide(pageNum),
                    to_concept: getConceptNameForSlide(pageNum + 1),
                    timestamp: new Date().toISOString()
                });
                
                pageNum++;
                queueRenderPage(pageNum);
            }

            function notifyConceptChange(conceptName) {
                const slideNumber = pageNum;

                attemptCount = 0;

                fetch('/change_concept', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        concept_name: conceptName,
                        slide_number: slideNumber
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Concept change notification sent:', data);
                })
                .catch(error => {
                    console.error('Error notifying concept change:', error);
                });
            }
            


            function getConceptNameForSlide(slideNumber) {
                const conceptMap = {
                    1: "Correlation ",
                    2: "Correlation",
                    3: "Correlation",
                    4: "Correlation",
                    5: "Confounders ",
                    6: "Confounders ",
                    7: "Moderators  ",
                    8: "Moderators  ",
                    9: "Moderators  "
                };
                
                const concept = conceptMap[slideNumber];
                return concept ? concept.trim() : "Unknown Concept";
            }

            document.getElementById('prev-page').addEventListener('click', onPrevPage);
            document.getElementById('next-page').addEventListener('click', onNextPage);

            document.querySelectorAll('.slide-nav-button').forEach(button => {
                button.addEventListener('click', function() {
                    const targetSlide = this.getAttribute('data-target-slide');
                    if (targetSlide) {
                        const slideNum = parseInt(targetSlide, 10);
                        if (!isNaN(slideNum)) {
                            logInteractionEvent('NAVIGATION', { 
                                button: 'direct_slide_navigation',
                                from_page: pageNum,
                                to_page: slideNum,
                                from_concept: getConceptNameForSlide(pageNum),
                                to_concept: getConceptNameForSlide(slideNum),
                                button_target: targetSlide,
                                timestamp: new Date().toISOString()
                            });
                            
                            pageNum = slideNum;
                            queueRenderPage(pageNum);
                            
                            const conceptName = getConceptNameForSlide(slideNum);
                            notifyConceptChange(conceptName);
                        }
                    }
                });
            });

            pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
                pdfDoc = pdfDoc_;
                document.getElementById('total-pages').textContent = pdfDoc.numPages;
                renderPage(pageNum);
            }).catch(err => {
                console.error('Error loading PDF:', err);
                alert('Failed to load PDF: ' + err.message);
            });

            const canvas = document.getElementById('voice-visualizer');
            canvas.width = 500;
            canvas.height = 40;
            const canvasCtx = canvas.getContext('2d');
            let audioContext, analyser, dataArray, animationId;
            let recognition = null; 

            const introAudioUrl = '/uploads/ai_audio/intro_message.mp3';

            // Siri Animation Functions
            function animateBlobs() {
                blobs.forEach((blob, index) => {
                    const speed = 2 + index * 0.5;
                    const time = performance.now() / 1000;
                    const x = Math.sin(time * speed) * 10;
                    const y = Math.cos(time * (speed + 0.5)) * 10;
                    
                    blob.style.transform = `translate(${x}px, ${y}px) scale(${0.8 + Math.sin(time * speed) * 0.1})`;
                });
                
                requestAnimationFrame(animateBlobs);
            }
            
            function createWave() {
                const wave = document.createElement('div');
                wave.className = 'wave';
                wave.id = `wave-${waveCount++}`;
                avatar.appendChild(wave);
                waves.push(wave);
                
                setTimeout(() => {
                    wave.style.transition = 'all 2s cubic-bezier(0.1, 0.8, 0.1, 1)';
                    wave.style.transform = 'scale(1.5)';
                    wave.style.opacity = '0';
                }, 10);
                
                setTimeout(() => {
                    avatar.removeChild(wave);
                    waves = waves.filter(w => w !== wave);
                }, 2000);
            }
            
            function activateSiriOrb() {
                if (isAnimating) return;
                isAnimating = true;
                
                createWave();
                setTimeout(createWave, 200);
                setTimeout(createWave, 400);
                
                siriOrb.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    siriOrb.style.transform = 'scale(1)';
                }, 300);
                
                blobs.forEach((blob, index) => {
                    const delay = index * 100;
                    setTimeout(() => {
                        blob.style.transform = 'scale(1.2) translate(0, 0)';
                        setTimeout(() => {
                            blob.style.transform = 'scale(1) translate(0, 0)';
                        }, 400);
                    }, delay);
                });
                
                setTimeout(() => {
                    isAnimating = false;
                }, 800);
            }
            
            animateBlobs();

            function initializeResize() {
                const modal = document.getElementById('chat-modal');
                let isResizing = false;
                let startX;
                let startWidth;
                let startRight;
                const MIN_CHATBOX_WIDTH = 450;

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle-left';
                modal.appendChild(resizeHandle);

                resizeHandle.addEventListener('mousedown', initDrag);

                function initDrag(e) {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = modal.offsetWidth;
                    startRight = window.innerWidth - (modal.offsetLeft + modal.offsetWidth);
                    
                    document.addEventListener('mousemove', doDrag);
                    document.addEventListener('mouseup', stopDrag);
                    e.preventDefault();
                }

                function doDrag(e) {
                    if (!isResizing) return;

                    const deltaX = startX - e.clientX;
                    const newWidth = startWidth + deltaX;
                    const finalWidth = Math.max(MIN_CHATBOX_WIDTH, newWidth);
                    
                    if (finalWidth <= window.innerWidth * 0.8) {
                        const newLeft = window.innerWidth - startRight - finalWidth;
                        
                        modal.style.width = finalWidth + 'px';
                        modal.style.left = newLeft + 'px';
                    }
                }

                function stopDrag() {
                    isResizing = false;
                    document.removeEventListener('mousemove', doDrag);
                    document.removeEventListener('mouseup', stopDrag);
                }
            }

            initializeResize();

            function getCurrentConcept() {
                const concept = getConceptNameForSlide(pageNum);
                return concept ? concept.trim() : "Unknown Concept";
            }

            const modalContent = document.querySelector('.modal-content');

            function logInteractionEvent(eventType, details = {}) {
                const currentConcept = getCurrentConcept();
                fetch('/log_interaction_event', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        event_type: eventType,
                        details: details,
                        concept_name: currentConcept
                    })
                }).catch(error => console.error('Error logging interaction:', error));
            }

            function showModal() {
                modal.style.display = 'block';
                document.body.classList.add('modal-open');
                
                document.querySelector('.container').classList.add('chat-open');
                document.getElementById('pdf-container').classList.add('chat-open');
                
                if (pdfDoc) {
                    setTimeout(() => {
                        queueRenderPage(pageNum);
                    }, 300);
                }

                setTimeout(() => {
                    modal.classList.add('show');
                    modalContent.classList.add('active'); 
                }, 10);
                
                logInteractionEvent('CHAT_WINDOW', { action: 'opened' });
                            
            if (!introPlayed) {
                introPlayed = true;
                fetch('/get_intro_audio')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success' && data.intro_audio_url) {
                            displayAudioMessage(data.intro_audio_url, 'ai', data.intro_text);
                        } else {
                            console.error('Error getting intro audio:', data.message || 'Unknown error');
                            displayAudioMessage(null, 'ai', "Welcome! I'm your AI assistant for this session. We'll be exploring the concept of Extraneous Variables, focusing on Correlation, Confounders, and Moderators. Please go through each concept and explain what you understand about them in your own words!");
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching intro audio:', error);
                        displayAudioMessage(null, 'ai', "Welcome! I'm your AI assistant for this session. We'll be exploring the concept of Extraneous Variables, focusing on Correlation, Confounders, and Moderators. Please go through each concept and explain what you understand about them in your own words!");
                    });
            }
            
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                    }).catch(err => {
                        console.error('Error resuming audio context:', err);
                    });
            }
    
                
                activateSiriOrb();
                
                currentConcept = getCurrentConcept();
                console.log("Current concept set to:", currentConcept);
                
                notifyConceptChange(currentConcept);
            }

            function handleAudioError(audio, durationDisplay) {
                audio.addEventListener('error', (e) => {
                    console.error('Audio loading error:', e);
                    durationDisplay.textContent = 'Error';
                    if (audio.src.includes('/uploads/')) {
                        const alternativePath = audio.src.replace('/uploads/', '/uploads/concept_audio/');
                        audio.src = alternativePath;
                        audio.load();
                    }
                });
            }

            function hideModal() {
                modal.classList.remove('show');
                modalContent.classList.remove('active');

                document.querySelector('.container').classList.remove('chat-open');
                document.getElementById('pdf-container').classList.remove('chat-open');
                
                logInteractionEvent('CHAT_WINDOW', { action: 'closed' });

                if (pdfDoc) {
                    setTimeout(() => {
                        queueRenderPage(pageNum);
                    }, 300);
                }

                setTimeout(() => {
                    modal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                }, 300); 
                
                stopAllAudio();
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }

            avatar.addEventListener('click', () => {
                if (modal.classList.contains('show')) {
                    logInteractionEvent('BUTTON_CLICK', { 
                        button: 'avatar',
                        action: 'hide_modal',
                        timestamp: new Date().toISOString()
                    });
                    hideModal();
                } else {
                    logInteractionEvent('BUTTON_CLICK', { 
                        button: 'avatar',
                        action: 'show_modal',
                        timestamp: new Date().toISOString()
                    });
                    showModal();
                }
            });


            closeModal.addEventListener('click', () => {
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'close_modal',
                    action: 'hide_modal',
                    timestamp: new Date().toISOString()
                });
                hideModal();
            });

            window.addEventListener('click', (event) => {
                if (event.target === modal) {
                    logInteractionEvent('BUTTON_CLICK', { 
                        button: 'modal_background',
                        action: 'hide_modal',
                        timestamp: new Date().toISOString()
                    });
                    hideModal();
                }
            });
            recordBtn.addEventListener('click', async () => {
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'record',
                    action: 'start_whatsapp_recording',
                    timestamp: new Date().toISOString()
                });
                startWhatsAppRecording();
            });

            // WhatsApp-style recording functionality
            let whatsAppRecorder = {
                isRecording: false,
                isPaused: false,
                startTime: null,
                pausedTime: 0,
                waveformBars: [],
                animationId: null,
                timerInterval: null,
                maxBars: 50
            };

            function startWhatsAppRecording() {
                const defaultControls = document.getElementById('default-controls');
                const whatsappRecorder = document.getElementById('whatsapp-recorder');
                
                defaultControls.style.display = 'none';
                whatsappRecorder.style.display = 'flex';
                
                initializeWhatsAppRecording();
            }

            async function initializeWhatsAppRecording() {
                try {
                    if (mediaRecorder) {
                        mediaRecorder = null;
                    }
                    if (audioContext && audioContext !== window.audioContext) {
                        await audioContext.close();
                    }

                    audioChunks = [];
                    whatsAppRecorder.isRecording = true;
                    whatsAppRecorder.isPaused = false;
                    whatsAppRecorder.startTime = Date.now();
                    whatsAppRecorder.pausedTime = 0;
                    
                    activateSiriOrb();
                    siriOrb.style.boxShadow = "0 0 20px 5px rgba(255, 255, 255, 0.7)";

                    logInteractionEvent('RECORDING', { 
                        action: 'started',
                        timestamp: new Date().toISOString()
                    });
                    
                    if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                        console.warn('Not on HTTPS - some features may not work');
                    }

                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('getUserMedia not supported in this browser');
                    }
                    
                    console.log('Requesting microphone access...');
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    
                    console.log('Microphone access granted');
                    logInteractionEvent('MICROPHONE', { 
                        action: 'permission_granted',
                        concept: getCurrentConcept(),
                        timestamp: new Date().toISOString()
                    });
                    
                    if (!window.audioContext) {
                        try {
                            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            console.log('AudioContext created successfully');
                        } catch (e) {
                            console.warn('AudioContext creation failed, visualizer will not work:', e);
                        }
                    }
                    
                    if (window.audioContext && window.audioContext.state === 'suspended') {
                        try {
                            await window.audioContext.resume();
                            console.log('AudioContext resumed');
                        } catch (e) {
                            console.warn('Failed to resume AudioContext:', e);
                        }
                    }

                    audioContext = window.audioContext;

                    if (audioContext) {
                        try {
                            // ensure analyzer is created robustly
                            analyser = audioContext.createAnalyser();
                            const source = audioContext.createMediaStreamSource(stream);
                            analyser.fftSize = 256;
                            analyser.smoothingTimeConstant = 0.8;
                            source.connect(analyser);
                            dataArray = new Uint8Array(analyser.frequencyBinCount);
                            console.log('Audio visualization setup completed (analyser created)');
                        } catch (e) {
                            console.warn('Audio visualization setup failed:', e);
                            analyser = null;
                        }
                    } else {
                        console.warn('No audioContext available, disabling visualization');
                        analyser = null;
                    }

                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/mp4';
                            if (!MediaRecorder.isTypeSupported(mimeType)) {
                                mimeType = ''; 
                            }
                        }
                    }
                    
                    console.log('Using MIME type:', mimeType || 'browser default');
                    mediaRecorder = new MediaRecorder(stream, mimeType ? {mimeType: mimeType} : {});
                    
                    mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event);
                        alert('Error recording audio: ' + event.error);
                        resetWhatsAppRecording();
                    };
                    
                    mediaRecorder.start();
                    console.log("WhatsApp-style MediaRecorder started", mediaRecorder.state);

                    logInteractionEvent('RECORDING', { 
                        action: 'media_recorder_started',
                        mime_type: mimeType || 'browser_default',
                        concept: getCurrentConcept(),
                        timestamp: new Date().toISOString()
                    });

                    startWhatsAppVisualization();
                    startRecordingTimer();
                    startLiveRecognition();
                    
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    
                    let errorMessage = 'Unable to access microphone. ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Please allow microphone permissions and try again.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'No microphone found. Please connect a microphone.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'Your browser does not support audio recording.';
                    } else if (error.message.includes('HTTPS')) {
                        errorMessage += 'This site must be accessed via HTTPS for microphone access.';
                    } else {
                        errorMessage += 'Error: ' + error.message;
                    }
                    
                    logInteractionEvent('MICROPHONE', { 
                        action: 'permission_denied_or_error',
                        error: error.message,
                        error_name: error.name,
                        concept: getCurrentConcept(),
                        timestamp: new Date().toISOString()
                    });
                    
                    alert(errorMessage);
                    resetWhatsAppRecording();
                }
            }

            function startWhatsAppVisualization() {
                const waveformBars = document.getElementById('waveform-bars');
                whatsAppRecorder.waveformBars = [];

                function addWaveformBar(volume) {
                    if (whatsAppRecorder.waveformBars.length >= whatsAppRecorder.maxBars) {
                        const oldBar = waveformBars.firstChild;
                        if (oldBar) {
                            waveformBars.removeChild(oldBar);
                            whatsAppRecorder.waveformBars.shift();
                        }
                    }

                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    
                    const height = Math.max(3, Math.min(26, (volume / 255) * 26));
                    bar.style.height = height + 'px';
                    
                    waveformBars.appendChild(bar);
                    whatsAppRecorder.waveformBars.push(bar);
                    
                    bar.classList.add('pulse');
                    setTimeout(() => bar.classList.remove('pulse'), 300);
                }

                function visualizeAudio() {
                    if (!whatsAppRecorder.isRecording) {
                        return; 
                    }
                    
                    if (whatsAppRecorder.isPaused) {
                        whatsAppRecorder.animationId = requestAnimationFrame(visualizeAudio);
                        return; 
                    }

                    if (analyser) {
                        const finalVolume = drawRMSVisualizer();
                        addWaveformBar(finalVolume);
                    } else {
                        const baseVolume = 80 + Math.random() * 60; 
                        const variation = (Math.sin(Date.now() / 200) * 30) + (Math.random() - 0.5) * 40;
                        const simulatedVolume = Math.max(40, Math.min(200, baseVolume + variation));
                        addWaveformBar(simulatedVolume);
                    }
                    
                    whatsAppRecorder.animationId = requestAnimationFrame(visualizeAudio);
                }

                visualizeAudio();
            }

            // Improved visualizer using time-domain RMS for more reliable volume meter
            function drawRMSVisualizer() {
                if (!analyser) return null;
                const buffer = new Uint8Array(analyser.fftSize);
                analyser.getByteTimeDomainData(buffer);
                // compute RMS
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    const v = (buffer[i] - 128) / 128; // normalize to -1..1
                    sum += v * v;
                }
                const rms = Math.sqrt(sum / buffer.length);
                return Math.min(255, Math.max(0, Math.floor(rms * 255 * 2)));
            }

            // Live speech recognition (Web Speech API) â€” shows interim results in the transcript box
            function startLiveRecognition() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.warn('Web Speech API not supported in this browser. Live transcript disabled.');
                    return;
                }

                const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
                try {
                    recognition = new SpeechRec();
                } catch (e) {
                    console.warn('Failed to create SpeechRecognition instance:', e);
                    recognition = null;
                    return;
                }

                recognition.lang = 'en-US';
                recognition.interimResults = true;
                recognition.continuous = true;


                let lastInterim = '';
                recognition.onresult = (event) => {
                    let interim = '';
                    let finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interim += event.results[i][0].transcript;
                        }
                    }

                    if (finalTranscript && finalTranscript.trim().length > 0) {
                        recognition._lastFinal = (recognition._lastFinal || '') + finalTranscript.trim() + ' ';
                        lastInterim = '';
                    }
                };

                recognition.onerror = (e) => {
                    console.warn('Speech recognition error:', e);
                };

                recognition.onend = () => {
                    console.log('Speech recognition ended');
                    recognition = null;
                };

                try {
                    recognition.start();
                    console.log('Live speech recognition started');
                } catch (e) {
                    console.warn('Recognition start failed:', e);
                }
            }

            function stopLiveRecognition() {
                if (recognition) {
                    try { recognition.stop(); } catch (e) { }
                    recognition = null;
                }
            }

            function escapeHtml(text) {
                return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }

            function startRecordingTimer() {
                const timerElement = document.querySelector('.recording-timer');
                
                whatsAppRecorder.timerInterval = setInterval(() => {
                    if (whatsAppRecorder.isPaused) {
                        return; 
                    }
                    
                    const currentTime = Date.now();
                    const elapsed = Math.floor((currentTime - whatsAppRecorder.startTime - whatsAppRecorder.pausedTime) / 1000);
                    
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }, 100); 
            }

            document.getElementById('cancel-record-btn').addEventListener('click', cancelWhatsAppRecording);
            document.getElementById('pause-record-btn').addEventListener('click', toggleWhatsAppRecording);
            document.getElementById('send-record-btn').addEventListener('click', sendWhatsAppRecording);

            function cancelWhatsAppRecording() {
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'cancel_recording',
                    recording_duration: whatsAppRecorder.startTime ? Math.floor((Date.now() - whatsAppRecorder.startTime - whatsAppRecorder.pausedTime) / 1000) : 0,
                    was_paused: whatsAppRecorder.isPaused,
                    concept: getCurrentConcept(),
                    timestamp: new Date().toISOString()
                });
                
                resetWhatsAppRecording();
                
                logInteractionEvent('RECORDING', { 
                    action: 'cancelled',
                    timestamp: new Date().toISOString()
                });
            }

            function toggleWhatsAppRecording() {
                console.log('Pause/Resume button clicked!'); // Debug log
                const pauseBtn = document.getElementById('pause-record-btn');
                const whatsappRecorderEl = document.getElementById('whatsapp-recorder');
                
                if (!whatsAppRecorder.isPaused) {
                    console.log('Pausing recording...');
                    
                    logInteractionEvent('BUTTON_CLICK', { 
                        button: 'pause_recording',
                        action: 'pause',
                        recording_duration: Math.floor((Date.now() - whatsAppRecorder.startTime - whatsAppRecorder.pausedTime) / 1000),
                        concept: getCurrentConcept(),
                        timestamp: new Date().toISOString()
                    });
                    
                    whatsAppRecorder.isPaused = true;
                    whatsAppRecorder.pauseStartTime = Date.now();
                    
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.pause();
                    }
                    
                    pauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    pauseBtn.classList.add('paused');
                    whatsappRecorderEl.classList.add('paused');
                    
                    if (whatsAppRecorder.animationId) {
                        cancelAnimationFrame(whatsAppRecorder.animationId);
                        whatsAppRecorder.animationId = null;
                    }
                    
                    logInteractionEvent('RECORDING', { 
                        action: 'paused',
                        timestamp: new Date().toISOString()
                    });
                    
                } else {
                    console.log('Resuming recording...');
                    
                    logInteractionEvent('BUTTON_CLICK', { 
                        button: 'pause_recording',
                        action: 'resume',
                        pause_duration: Math.floor((Date.now() - whatsAppRecorder.pauseStartTime) / 1000),
                        total_recording_duration: Math.floor((Date.now() - whatsAppRecorder.startTime - whatsAppRecorder.pausedTime) / 1000),
                        concept: getCurrentConcept(),
                        timestamp: new Date().toISOString()
                    });
                    
                    whatsAppRecorder.isPaused = false;
                    whatsAppRecorder.pausedTime += Date.now() - whatsAppRecorder.pauseStartTime;
                    
                    if (mediaRecorder && mediaRecorder.state === 'paused') {
                        mediaRecorder.resume();
                    }
                    
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    pauseBtn.classList.remove('paused');
                    whatsappRecorderEl.classList.remove('paused');
                    
                    startWhatsAppVisualizationContinued();
                    
                    logInteractionEvent('RECORDING', { 
                        action: 'resumed',
                        timestamp: new Date().toISOString()
                    });
                }
            }

            function startWhatsAppVisualizationContinued() {
                if (whatsAppRecorder.animationId) return; 

                function addWaveformBar(volume) {
                    const waveformBars = document.getElementById('waveform-bars');
                    
                    if (whatsAppRecorder.waveformBars.length >= whatsAppRecorder.maxBars) {
                        const oldBar = waveformBars.firstChild;
                        if (oldBar) {
                            waveformBars.removeChild(oldBar);
                            whatsAppRecorder.waveformBars.shift();
                        }
                    }

                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    
                    const height = Math.max(3, Math.min(26, (volume / 255) * 26));
                    bar.style.height = height + 'px';
                    
                    waveformBars.appendChild(bar);
                    whatsAppRecorder.waveformBars.push(bar);
                    
                    bar.classList.add('pulse');
                    setTimeout(() => bar.classList.remove('pulse'), 300);
                }

                function visualizeAudio() {
                    if (!whatsAppRecorder.isRecording) {
                        return; 
                    }
                    
                    if (whatsAppRecorder.isPaused) {
                        whatsAppRecorder.animationId = requestAnimationFrame(visualizeAudio);
                        return; 
                    }

                    if (analyser) {
                        const finalVolume = drawRMSVisualizer();
                        addWaveformBar(finalVolume);
                    } else {
                        const baseVolume = 80 + Math.random() * 60; 
                        const variation = (Math.sin(Date.now() / 200) * 30) + (Math.random() - 0.5) * 40;
                        const simulatedVolume = Math.max(40, Math.min(200, baseVolume + variation));
                        addWaveformBar(simulatedVolume);
                    }
                    
                    whatsAppRecorder.animationId = requestAnimationFrame(visualizeAudio);
                }

                visualizeAudio();
            }

            async function sendWhatsAppRecording() {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    console.warn('MediaRecorder not active');
                    return;
                }
                
                const recordingDuration = Math.floor((Date.now() - whatsAppRecorder.startTime - whatsAppRecorder.pausedTime) / 1000);
                
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'send_recording',
                    recording_duration: recordingDuration,
                    pause_count: whatsAppRecorder.pausedTime > 0 ? 1 : 0, 
                    total_paused_time: Math.floor(whatsAppRecorder.pausedTime / 1000),
                    concept: getCurrentConcept(),
                    timestamp: new Date().toISOString()
                });
                
                console.log("Sending WhatsApp-style recording", mediaRecorder.state);
                whatsAppRecorder.isRecording = false;
                
                logInteractionEvent('RECORDING', { 
                    action: 'sent',
                    timestamp: new Date().toISOString()
                });

                try {
                    if (mediaRecorder.state === 'paused') {
                        mediaRecorder.resume();
                    }
                    mediaRecorder.stop();
                } catch (err) {
                    console.error('Error stopping MediaRecorder:', err);
                    resetWhatsAppRecording();
                    stopLiveRecognition();
                    return;
                }

                mediaRecorder.onstop = async () => {
                    try {
                        updateInputBarState('loading');
                        
                        if (audioChunks.length === 0) {
                            throw new Error('No audio data recorded');
                        }
                        
                        currentConcept = getCurrentConcept();
                        console.log("Sending WhatsApp audio for concept:", currentConcept);
                        
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                        
                        await submitMessage(null, audioBlob);
                        stopLiveRecognition();
                        resetWhatsAppRecording();

                    } catch (error) {
                        console.error('Error processing audio:', error);
                        alert('Error processing audio: ' + error.message);
                        stopLiveRecognition();
                        resetWhatsAppRecording();
                    } finally {
                        loadingIndicator.classList.remove('active');
                    }
                };
            }

            function resetWhatsAppRecording() {
                if (whatsAppRecorder.animationId) {
                    cancelAnimationFrame(whatsAppRecorder.animationId);
                }
                if (whatsAppRecorder.timerInterval) {
                    clearInterval(whatsAppRecorder.timerInterval);
                }

                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    try {
                        mediaRecorder.stop();
                    } catch (e) {
                        console.warn('Error stopping MediaRecorder during reset:', e);
                    }
                }

                whatsAppRecorder.isRecording = false;
                whatsAppRecorder.isPaused = false;
                whatsAppRecorder.startTime = null;
                whatsAppRecorder.pausedTime = 0;
                whatsAppRecorder.waveformBars = [];

                const defaultControls = document.getElementById('default-controls');
                const whatsappRecorder = document.getElementById('whatsapp-recorder');
                const waveformBars = document.getElementById('waveform-bars');
                const timerElement = document.querySelector('.recording-timer');
                const pauseBtn = document.getElementById('pause-record-btn');
                
                defaultControls.style.display = 'flex';
                whatsappRecorder.style.display = 'none';
                
                waveformBars.innerHTML = '';
                timerElement.textContent = '0:00';
                
                pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                pauseBtn.classList.remove('paused');
                
                siriOrb.style.boxShadow = "none";
                
                audioChunks = [];
                isRecording = false;
                
                updateInputBarState('idle');
            }

            async function submitMessage(message = null, audioBlob = null) {
                try {
                    const formData = new FormData();
                    const currentConcept = getCurrentConcept();
                    
                    const currentParticipantId = window.participantId;
                    const currentTrialType = window.currentTrialType;  
                    
                    if (!currentParticipantId || !currentTrialType) {
                        console.error('Missing participant ID or trial type');
                        throw new Error('Session information not found');
                    }
                    
                    if (message) {
                        formData.append('message', message);
                    }
                    
                    if (audioBlob) {
                        formData.append('audio', audioBlob);
                        const userAudioUrl = URL.createObjectURL(audioBlob);
                        displayAudioMessage(userAudioUrl, 'user', 'processing...');
                        logInteractionEvent('RECORDING', { 
                            action: 'submitted',
                            timestamp: new Date().toISOString(),
                            blobSize: audioBlob.size
                        });
                    }
                    
                    formData.append('concept_name', currentConcept);
                    
                    console.log("Sending data to server with concept:", currentConcept);
                    
                    if (window.USE_STREAMING) {
                        return await submitMessageStream(formData, currentParticipantId);
                    }

                    const response = await fetch('/submit_message', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `Server responded with status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log("Server response:", data);

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    document.getElementById('pause-btn').style.display = 'none';
                    document.getElementById('delete-btn').style.display = 'none';
                    document.getElementById('record-btn').style.display = 'flex';
                    document.getElementById('record-btn').innerHTML = '<i class="fas fa-microphone"></i>';

                    const userMessages = document.querySelectorAll('.user-message');
                    const lastUserMessage = userMessages[userMessages.length - 1];
                    if (lastUserMessage) {
                        const transcriptDiv = lastUserMessage.querySelector('.transcript-text');
                        if (transcriptDiv) {
                            transcriptDiv.textContent = data.user_transcript || message;
                        }
                    }

                    attemptCount = data.attempt_count;


                    if (data.ai_audio_url) {
                        const aiAudioUrl = `/uploads/User Data/${currentParticipantId}/${data.ai_audio_url}`;
                        console.log('AI Audio URL:', aiAudioUrl); // Debug print
                        displayAudioMessage(aiAudioUrl, 'ai', data.response);
                        activateSiriOrb();

                        updateInputBarState('idle');
                    } else {
                        console.error('No AI audio URL in response');
                        updateInputBarState('idle');
                    }
                    
                    return data;
                } catch (error) {
                    console.error('Error in submitMessage:', error);
                    updateInputBarState('idle');
                    throw error;
                }
            }

            async function submitMessageStream(formData, currentParticipantId) {
                const streamResponse = await fetch('/stream_submit_message', {
                    method: 'POST',
                    body: formData
                });

                if (!streamResponse.ok) {
                    const errBody = await streamResponse.json().catch(()=>null);
                    throw new Error(errBody && errBody.message ? errBody.message : 'Stream request failed');
                }

                const chatContainer = document.getElementById('chat-container');
                const aiBubble = document.createElement('div');
                aiBubble.className = 'chat-message ai-message streaming';
                aiBubble.textContent = '';
                chatContainer.appendChild(aiBubble);

                const reader = streamResponse.body.getReader();
                const decoder = new TextDecoder();
                let finalText = '';
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;

                    const markerStart = buffer.indexOf('__JSON__START__');
                    if (markerStart !== -1) {
                        finalText += buffer.slice(0, markerStart);
                        aiBubble.textContent = finalText;

                        const start = markerStart + '__JSON__START__'.length;
                        const endMarker = '__JSON__END__';
                        const end = buffer.indexOf(endMarker, start);
                        if (end !== -1) {
                            const jsonText = buffer.slice(start, end);
                            let meta = null;
                            try { meta = JSON.parse(jsonText); } catch (e) { console.error('Invalid meta JSON', e); }

                            if (meta) {
                                attemptCount = meta.attempt_count || (attemptCount || 0);
                                const userMessages = document.querySelectorAll('.user-message');
                                const lastUserMessage = userMessages[userMessages.length - 1];
                                if (lastUserMessage) {
                                    const transcriptDiv = lastUserMessage.querySelector('.transcript-text');
                                    if (transcriptDiv) transcriptDiv.textContent = meta.response || '';
                                }

                                const aiAudioUrl = `/uploads/User Data/${currentParticipantId}/${meta.ai_audio_url}`;
                                displayAudioMessage(aiAudioUrl, 'ai', meta.response || finalText);

                                document.getElementById('pause-btn').style.display = 'none';
                                document.getElementById('delete-btn').style.display = 'none';
                                document.getElementById('record-btn').style.display = 'flex';
                                document.getElementById('record-btn').innerHTML = '<i class="fas fa-microphone"></i>';

                                activateSiriOrb();
                                updateInputBarState('idle');
                            }

                            buffer = buffer.slice(end + endMarker.length);
                            break;
                        }
                    } else {
                        finalText += chunk;
                        aiBubble.textContent = finalText;
                        if (buffer.length > 20000) buffer = buffer.slice(-10000);
                    }
                }

                return { status: 'success', response: finalText };
            }

            async function getAudioDuration(audioBlob) {
                return new Promise((resolve) => {
                    const audio = new Audio();
                    audio.src = URL.createObjectURL(audioBlob);
                    
                    audio.addEventListener('loadedmetadata', () => {
                        URL.revokeObjectURL(audio.src);
                        resolve(audio.duration.toFixed(2));
                    });
                    
                    audio.addEventListener('error', () => {
                        URL.revokeObjectURL(audio.src);
                        resolve('unknown');
                    });
                });
            }

            function togglePause() {
                console.warn('togglePause called - using WhatsApp recorder pause instead');
            }

            function deleteRecording() {
                console.log('Delete recording called - resetting any active recording');
                
                if (whatsAppRecorder.isRecording) {
                    resetWhatsAppRecording();
                    return;
                }
                
                try {
                    stopLiveRecognition();
                    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                        console.log('Stopping media recorder');
                        mediaRecorder.stop();
                    }
                    
                    audioChunks = [];
                    isRecording = false;
                    isPaused = false;
                    
                    const recordBtn = document.getElementById('record-btn');
                    recordBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                    
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                    
                    const canvas = document.getElementById('voice-visualizer');
                    const canvasCtx = canvas.getContext('2d');
                    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    if (siriOrb) {
                        siriOrb.style.boxShadow = "none";
                    }
                    updateInputBarState('idle');
                    
                    if (audioContext && audioContext !== window.audioContext) {
                        audioContext.close().catch(console.error);
                    }
                    
                    mediaRecorder = null;
                    
                    logInteractionEvent('RECORDING', { 
                        action: 'deleted',
                        timestamp: new Date().toISOString()
                    });
                    
                    console.log('Recording deleted successfully');
                } catch (error) {
                    console.error('Error deleting recording:', error);
                    updateInputBarState('idle');
                }
            }

            document.getElementById('delete-btn').addEventListener('click', () => {
                logInteractionEvent('BUTTON_CLICK', { 
                    button: 'delete_recording',
                    was_recording: isRecording,
                    was_paused: isPaused,
                    concept: getCurrentConcept(),
                    timestamp: new Date().toISOString()
                });
                deleteRecording();
            });

            function resetRecordingState() {
                isRecording = false;
                isPaused = false;
                recordBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                document.getElementById('pause-btn').style.display = 'none';
                document.getElementById('delete-btn').style.display = 'none';
                recordBtn.style.display = 'flex';
                visualizer.style.display = 'none';
                siriOrb.style.boxShadow = "none";
                if (audioContext && audioContext !== window.audioContext) {
                    audioContext.close().catch(console.error);
                }
            }

            function displayAudioMessage(audioUrl, sender, transcript) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender}-message`;

                if (transcript) {
                    const transcriptDiv = document.createElement('div');
                    transcriptDiv.className = 'transcript-text';

                    if (sender === 'ai') {
                        transcriptDiv.style.display = 'none';
                        transcriptDiv.classList.add('transcript-unplayed');
                        transcriptDiv.textContent = transcript;
                    } else if (sender === 'user' && transcript === 'processing...') {
                        const loadingIcon = document.createElement('i');
                        loadingIcon.className = 'fas fa-spinner fa-spin loading-spinner-icon';
                        transcriptDiv.appendChild(loadingIcon);
                    } else {
                        transcriptDiv.textContent = transcript;
                    }
                    
                    messageDiv.appendChild(transcriptDiv);
                }

                const audioContainer = document.createElement('div');
                audioContainer.className = 'audio-container';

                const playButton = document.createElement('div');
                playButton.className = 'play-button';
                playButton.innerHTML = '<i class="fas fa-play"></i>';

                const waveformContainer = document.createElement('div');
                waveformContainer.className = 'waveform-container';

                const waveformVisualization = document.createElement('div');
                waveformVisualization.className = 'waveform-visualization';

                const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                const numberOfBars = 40;
                for (let i = 0; i < numberOfBars; i++) {
                    const waveBar = document.createElement('div');
                    waveBar.className = 'wave-bar';
                    waveBar.style.height = '40%'; 
                    waveformVisualization.appendChild(waveBar);
                }

                fetch(audioUrl)
                    .then(response => response.arrayBuffer())
                    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        const channelData = audioBuffer.getChannelData(0);
                        const barSegmentLength = Math.floor(channelData.length / numberOfBars);
                        const bars = waveformVisualization.children;

                        for (let i = 0; i < numberOfBars; i++) {
                            const start = i * barSegmentLength;
                            const end = start + barSegmentLength;
                            let maxAmplitude = 0; 

                            for (let j = start; j < end; j++) {
                                maxAmplitude = Math.max(maxAmplitude, Math.abs(channelData[j]));
                            }

                            const heightPercentage = Math.min(Math.max(maxAmplitude * 100, 5), 50);
                            bars[i].style.height = `${heightPercentage}%`;
                        }
                    })
                    .catch(error => {
                        console.error('Error analyzing audio:', error);
                    });
                
                const progressIndicator = document.createElement('div');
                progressIndicator.className = 'progress-indicator';
                
                waveformContainer.appendChild(waveformVisualization);
                waveformContainer.appendChild(progressIndicator);
                
                const durationDisplay = document.createElement('div');
                durationDisplay.className = 'duration-display';
                durationDisplay.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                const speedToggle = document.createElement('button');
                speedToggle.className = 'speed-toggle';
                speedToggle.textContent = '1x';
                
                const audio = document.createElement('audio');
                audio.preload = 'metadata';


                audio.controls = true;
                if (sender === 'ai' && transcript) {
                    // Best-effort TTS: request synthesized audio and set as source
                    fetch('/synthesize', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: transcript, format: 'mp3' })
                    }).then(res => {
                        if (!res.ok) throw new Error('Synthesis failed');
                        return res.arrayBuffer();
                    }).then(ab => {
                        const blob = new Blob([ab], { type: 'audio/mpeg' });
                        const url = URL.createObjectURL(blob);
                        audio.src = url;
                        audio.load();
                    }).catch(err => {
                        console.error('Synthesis failed, falling back to original source', err);
                        audio.src = audioUrl.startsWith('/uploads/') ? audioUrl : `/uploads/${audioUrl}`;
                        audio.load();
                    });
                } else {
                    audio.src = audioUrl.startsWith('/uploads/') ? audioUrl : `/uploads/${audioUrl}`;
                }

                playButton.style.pointerEvents = 'none';
                playButton.style.opacity = '0.6';
                playButton.title = 'Loading audio...';


                let audioPlayable = false;
                let transcriptReady = !(sender === 'user' && transcript === 'processing...');

                function updatePlayability() {
                    if (sender === 'user') {
                        if (transcriptReady || audioPlayable) {
                            playButton.style.pointerEvents = 'auto';
                            playButton.style.opacity = '1';
                            playButton.title = 'Play audio';
                        } else {
                            playButton.style.pointerEvents = 'none';
                            playButton.style.opacity = '0.6';
                            playButton.title = 'Loading audio...';
                        }
                    } else {
                        if (audioPlayable) {
                            playButton.style.pointerEvents = 'auto';
                            playButton.style.opacity = '1';
                            playButton.title = 'Play audio';
                        } else {
                            playButton.style.pointerEvents = 'none';
                            playButton.style.opacity = '0.6';
                            playButton.title = 'Loading audio...';
                        }
                    }
                }

                function markAudioPlayable() {
                    audioPlayable = true;
                    updatePlayability();
                    try {
                        if (isFinite(audio.duration) && audio.duration > 0) {
                            const mins = Math.floor(audio.duration / 60);
                            const secs = Math.floor(audio.duration % 60).toString().padStart(2, '0');
                            durationDisplay.textContent = `${mins}:${secs}`;
                        } else {
                            const setDurationOnce = () => {
                                if (isFinite(audio.duration) && audio.duration > 0) {
                                    const mins = Math.floor(audio.duration / 60);
                                    const secs = Math.floor(audio.duration % 60).toString().padStart(2, '0');
                                    durationDisplay.textContent = `${mins}:${secs}`;
                                }
                                try { audio.removeEventListener('loadedmetadata', setDurationOnce); } catch (e) {}
                            };
                            audio.addEventListener('loadedmetadata', setDurationOnce);
                        }
                    } catch (e) { console.warn('Error setting duration display:', e); }
                    try {
                        audio.removeEventListener('canplay', markAudioPlayable);
                        audio.removeEventListener('canplaythrough', markAudioPlayable);
                        audio.removeEventListener('loadedmetadata', markAudioPlayable);
                    } catch (e) {}
                }

                audio.addEventListener('canplay', markAudioPlayable);
                audio.addEventListener('canplaythrough', markAudioPlayable);
                audio.addEventListener('loadedmetadata', markAudioPlayable);

                if (sender === 'user' && transcript === 'processing...') {
                    const observer = new MutationObserver((mutations) => {
                        const text = transcriptDiv.textContent || '';
                        if (text && text.trim() && text.trim() !== 'processing...') {
                            transcriptReady = true;
                            updatePlayability();
                            try { observer.disconnect(); } catch (e) {}
                        }
                    });
                    try {
                        observer.observe(transcriptDiv, { childList: true, subtree: true, characterData: true });
                    } catch (e) {
                        const pollId = setInterval(() => {
                            const text = transcriptDiv.textContent || '';
                            if (text && text.trim() && text.trim() !== 'processing...') {
                                transcriptReady = true;
                                updatePlayability();
                                clearInterval(pollId);
                            }
                        }, 500);
                    }
                } else {
                    transcriptReady = true;
                    updatePlayability();
                }

                let speedIndex = 0;
                const speeds = [1, 1.5, 2];
                try { audio.playbackRate = speeds[speedIndex]; } catch (e) { /* ignore if audio not ready */ }
                playButton.addEventListener('click', () => {
                    if (playButton.style.pointerEvents === 'none') return;

                    if (audio.paused) {
                        logInteractionEvent('BUTTON_CLICK', { 
                            button: 'audio_play',
                            sender: sender,
                            audio_duration: audio.duration || 'unknown',
                            concept: getCurrentConcept(),
                            timestamp: new Date().toISOString()
                        });

                        stopAllAudio();

                        const playPromise = audio.play();
                        const startPlaybackActions = () => {
                            playButton.innerHTML = '<i class="fas fa-pause"></i>';
                            if (sender === 'ai') {
                                siriOrb.style.boxShadow = "0 0 20px 5px rgba(0, 128, 255, 0.7)";

                                const transcriptDiv = messageDiv.querySelector('.transcript-text.transcript-unplayed');
                                if (transcriptDiv) {
                                    transcriptDiv.style.display = 'block';
                                    transcriptDiv.style.opacity = '1';
                                    transcriptDiv.classList.remove('transcript-unplayed');

                                    const fullText = transcriptDiv.textContent || '';
                                    const words = fullText.trim().split(/\s+/).filter(Boolean);
                                    transcriptDiv.textContent = '';

                                    if (words.length === 0) {
                                        transcriptDiv.textContent = fullText;
                                    } else {
                                        transcriptDiv.innerHTML = words.map(w => `<span class=\"word\" style=\"opacity:0; transition: opacity 0.12s linear;\">${escapeHtml(w)}</span>`).join(' ');
                                        const spans = Array.from(transcriptDiv.querySelectorAll('.word'));

                                        if (messageDiv._revealHandler) {
                                            try { audio.removeEventListener('timeupdate', messageDiv._revealHandler); } catch (e) {}
                                        }
                                        if (messageDiv._revealEndHandler) {
                                            try { audio.removeEventListener('ended', messageDiv._revealEndHandler); } catch (e) {}
                                        }

                                        function revealByTime() {
                                            if (!isFinite(audio.duration) || audio.duration <= 0) return;
                                            const t = Math.max(0, Math.min(audio.currentTime, audio.duration));
                                            const fraction = t / audio.duration;
                                            const revealCount = Math.floor(fraction * words.length);
                                            for (let i = 0; i < revealCount; i++) {
                                                const sp = spans[i];
                                                if (sp && sp.style.opacity === '0') sp.style.opacity = '1';
                                            }
                                        }

                                        function revealEnded() {
                                            spans.forEach(sp => sp.style.opacity = '1');
                                            try { audio.removeEventListener('timeupdate', messageDiv._revealHandler); } catch (e) {}
                                            try { audio.removeEventListener('ended', messageDiv._revealEndHandler); } catch (e) {}
                                            delete messageDiv._revealHandler;
                                            delete messageDiv._revealEndHandler;
                                        }

                                        messageDiv._revealHandler = revealByTime;
                                        messageDiv._revealEndHandler = revealEnded;

                                        audio.addEventListener('timeupdate', messageDiv._revealHandler);
                                        audio.addEventListener('ended', messageDiv._revealEndHandler);

                                        audio.addEventListener('play', revealByTime, { once: true });
                                    }

                                    logInteractionEvent('TRANSCRIPT', {
                                        action: 'playback_reveal_started',
                                        timestamp: new Date().toISOString()
                                    });
                                }
                            }

                            logInteractionEvent('AUDIO_PLAYBACK', { 
                                action: 'started',
                                timestamp: audio.currentTime.toFixed(2)
                            });
                        };

                        if (playPromise !== undefined) {
                            playPromise.then(() => {
                                startPlaybackActions();
                            }).catch(err => {
                                console.error('Audio play failed:', err);
                                playButton.innerHTML = '<i class="fas fa-play"></i>';
                            });
                        } else {
                            startPlaybackActions();
                        }
                    } else {
                        logInteractionEvent('BUTTON_CLICK', { 
                            button: 'audio_pause',
                            sender: sender,
                            audio_position: audio.currentTime.toFixed(2),
                            concept: getCurrentConcept(),
                            timestamp: new Date().toISOString()
                        });
                        
                        audio.pause();
                        playButton.innerHTML = '<i class="fas fa-play"></i>';
                        if (sender === 'ai') {
                            siriOrb.style.boxShadow = "none";
                        }
                        logInteractionEvent('AUDIO_PLAYBACK', { 
                            action: 'paused',
                            timestamp: audio.currentTime.toFixed(2)
                        });
                    }
                }); 

                speedToggle.addEventListener('click', () => {
                    speedIndex = (speedIndex + 1) % speeds.length;
                    const newSpeed = speeds[speedIndex];
                    audio.playbackRate = newSpeed;
                    speedToggle.textContent = newSpeed + 'x';
                    
                    logInteractionEvent('BUTTON_CLICK', { 
                        button: 'audio_speed_toggle',
                        new_speed: newSpeed,
                        sender: sender,
                        concept: getCurrentConcept(),
                        timestamp: new Date().toISOString()
                    });
                    
                    logInteractionEvent('AUDIO_SPEED', { speed: newSpeed });
                });

                audio.addEventListener('timeupdate', () => {
                    if (isFinite(audio.duration) && audio.duration > 0) {
                        const percent = (audio.currentTime / audio.duration) * 100;
                        progressIndicator.style.left = `${percent}%`;
                        
                        const remainingTime = audio.duration - audio.currentTime;
                        const remainingMins = Math.floor(remainingTime / 60);
                        const remainingSecs = Math.floor(remainingTime % 60).toString().padStart(2, '0');
                        
                        durationDisplay.textContent = `${remainingMins}:${remainingSecs}`;
                    }
                });

                waveformContainer.addEventListener('click', (e) => {
                    if (isFinite(audio.duration)) {
                        const rect = waveformContainer.getBoundingClientRect();
                        const clickPosition = (e.clientX - rect.left) / rect.width;
                        const targetTime = clickPosition * audio.duration;
                        
                        logInteractionEvent('BUTTON_CLICK', { 
                            button: 'audio_waveform_seek',
                            sender: sender,
                            from_time: audio.currentTime.toFixed(2),
                            to_time: targetTime.toFixed(2),
                            seek_percentage: (clickPosition * 100).toFixed(1),
                            concept: getCurrentConcept(),
                            timestamp: new Date().toISOString()
                        });
                        
                        audio.currentTime = targetTime;
                    }
                });

                audio.addEventListener('ended', () => {
                    logInteractionEvent('AUDIO_PLAYBACK', { 
                        action: 'finished',
                        sender: sender,
                        duration: audio.duration.toFixed(2),
                        concept: getCurrentConcept(),
                        timestamp: new Date().toISOString()
                    });
                    
                    playButton.innerHTML = '<i class="fas fa-play"></i>';
                    progressIndicator.style.left = '0%';
                    if (sender === 'ai') {
                        siriOrb.style.boxShadow = "none";
                    }
                    if (isFinite(audio.duration) && audio.duration > 0) {
                        const minutes = Math.floor(audio.duration / 60);
                        const seconds = Math.floor(audio.duration % 60);
                        durationDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                    logInteractionEvent('AUDIO_PLAYBACK', { 
                        action: 'ended',
                        timestamp: audio.duration.toFixed(2)
                    });
                });

                const audioControls = document.createElement('div');
                audioControls.className = 'audio-controls';

                audioControls.appendChild(durationDisplay);
                audioControls.appendChild(speedToggle);

                audioContainer.appendChild(audioControls);
                audioContainer.appendChild(playButton);
                audioContainer.appendChild(waveformContainer);
                audioContainer.appendChild(durationDisplay);
                audioContainer.appendChild(speedToggle);
                messageDiv.appendChild(audioContainer);
                
                chatContainer.appendChild(messageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;

                if (sender === 'user' && audioUrl.startsWith('blob:')) {
                    console.log("Processing blob URL for user audio:", audioUrl);
                    
                    const metadataTimeout = setTimeout(() => {
                        if (durationDisplay.innerHTML.includes('fa-spinner')) {
                            durationDisplay.innerHTML = '<i class="fas fa-exclamation-circle"></i>';
                            console.log('Using error icon - metadata loading timeout');
                        }
                    }, 500);

                    const metadataAudio = new Audio();
                    metadataAudio.preload = 'metadata';
                    
                    metadataAudio.addEventListener('loadedmetadata', () => {
                        clearTimeout(metadataTimeout);
                        if (isFinite(metadataAudio.duration) && metadataAudio.duration > 0) {
                            const mins = Math.floor(metadataAudio.duration / 60);
                            const secs = Math.floor(metadataAudio.duration % 60).toString().padStart(2, '0');
                            durationDisplay.textContent = `${mins}:${secs}`;
                            console.log(`Audio metadata loaded. Duration: ${metadataAudio.duration}s`);
                        }
                    });
                    
                    metadataAudio.addEventListener('error', (e) => {
                        console.error('Error loading audio metadata:', e);
                        durationDisplay.innerHTML = '<i class="fas fa-exclamation-circle"></i>';
                    });
                    
                    metadataAudio.src = audioUrl;
                    metadataAudio.load();
                    
                    audio.src = audioUrl;
                    audio.load();
                    
                    if (window.audioContext) {
                        fetch(audioUrl)
                            .then(response => response.blob())
                            .then(blob => {
                                const fileReader = new FileReader();
                                fileReader.onload = function() {
                                    const arrayBuffer = this.result;
                                    
                                    window.audioContext.decodeAudioData(arrayBuffer)
                                        .then(decodedData => {
                                            clearTimeout(metadataTimeout);
                                            const duration = decodedData.duration;
                                            const mins = Math.floor(duration / 60);
                                            const secs = Math.floor(duration % 60).toString().padStart(2, '0');
                                            durationDisplay.textContent = `${mins}:${secs}`;
                                            console.log(`Decoded audio duration: ${duration}s`);
                                            
                                            if (!isFinite(audio.duration) || audio.duration <= 0) {
                                                audio.load();
                                            }
                                        })
                                        .catch(err => {
                                            console.error('Error decoding audio data:', err);
                                            estimateDurationFromBlob(blob, durationDisplay, metadataTimeout);
                                        });
                                };
                                
                                fileReader.readAsArrayBuffer(blob);
                            })
                            .catch(err => {
                                console.error('Error fetching blob for decoding:', err);
                                
                                const tempAudio = new Audio();
                                
                                tempAudio.addEventListener('loadedmetadata', () => {
                                    clearTimeout(metadataTimeout);
                                    if (isFinite(tempAudio.duration) && tempAudio.duration > 0) {
                                        const mins = Math.floor(tempAudio.duration / 60);
                                        const secs = Math.floor(tempAudio.duration % 60).toString().padStart(2, '0');
                                        durationDisplay.textContent = `${mins}:${secs}`;
                                        console.log(`Temp audio metadata loaded. Duration: ${tempAudio.duration}s`);
                                    }
                                });
                                
                                tempAudio.src = audioUrl;
                                tempAudio.load();
                            });
                    } else {
                        const tempAudio = new Audio();
                        
                        tempAudio.addEventListener('loadedmetadata', () => {
                            clearTimeout(metadataTimeout);
                            if (isFinite(tempAudio.duration) && tempAudio.duration > 0) {
                                const mins = Math.floor(tempAudio.duration / 60);
                                const secs = Math.floor(tempAudio.duration % 60).toString().padStart(2, '0');
                                durationDisplay.textContent = `${mins}:${secs}`;
                                console.log(`Temp audio metadata loaded. Duration: ${tempAudio.duration}s`);
                            }
                        });
                        
                        fetch(audioUrl)
                            .then(response => response.blob())
                            .then(blob => {
                                estimateDurationFromBlob(blob, durationDisplay, metadataTimeout);
                            })
                            .catch(err => console.error('Error fetching blob:', err));
                        
                        tempAudio.src = audioUrl;
                        tempAudio.load();
                    }
                }
                return messageDiv;
            }

            function estimateDurationFromBlob(blob, durationDisplay, timeoutToCancel) {
                if (blob.size > 0) {
                    const estimatedSecs = Math.max(1, blob.size / 16000); 
                    const mins = Math.floor(estimatedSecs / 60);
                    const secs = Math.floor(estimatedSecs % 60).toString().padStart(2, '0');
                    
                    if (durationDisplay.innerHTML.includes('fa-spinner') || 
                        durationDisplay.innerHTML.includes('fa-exclamation-circle')) {
                        durationDisplay.textContent = `${mins}:${secs}`;
                        console.log(`Estimated duration from blob size (${blob.size} bytes): ${mins}:${secs}`);
                        
                        if (timeoutToCancel) {
                            clearTimeout(timeoutToCancel);
                        }
                    }
                }
            }

                    function stopAllAudio() {
                        const audios = document.querySelectorAll('audio');
                        audios.forEach(audio => {
                            audio.pause();
                            const playButton = audio.parentElement.querySelector('.play-button');
                            if (playButton) {
                                playButton.innerHTML = '<i class="fas fa-play"></i>';
                            }
                        });
                        siriOrb.style.boxShadow = "none";
                    }

                    function moveToNextSlide() {
                        onNextPage();
                    }
                });
            </script>
</body>
</html> 































